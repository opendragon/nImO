{\rtf1\ansi\ansicpg1252\cocoartf1404\cocoasubrtf460
{\fonttbl\f0\fswiss\fcharset0 Helvetica;}
{\colortbl;\red255\green255\blue255;\red133\green0\blue175;}
\margl1440\margr1440\vieww24540\viewh16020\viewkind0
\deftab720
\pard\pardeftab720\partightenfactor0

\f0\fs28 \cf0 \expnd0\expndtw0\kerning0
Three kinds of data -\
1) Signed integer\
2) 64-bit floating point\
3) Character string / binary blob\
4) Structures\
\
Lead byte:\
bit0..1\
	00 signed integer [Enumerable]\
                bit2=0 short value\
                      bit3..7 (-32..31) [bit 3 is the sign bit]\
                bit2=1 long value\
                      bit3..4 Reserved (set to zero)\
                      bit5..7 number of bytes to follow-1 (1..8), MSB-first, sign extended from first byte [bit 0 of the first byte is the sign bit]\
	01 floating-point [Not Enumerable]\
                bit2=0 floats [32-bit] \{not currently used\}\
                bit2=1 doubles [64-bit]\
                bit3=0 short count of floating-point values to follow\
                      bit4..7 (0..15)\
                bit3=1 long count of floating-point values in next byte(s)\
                      bit4 Reserved (set to zero)\
                      bit5..7 number of bytes for count-1 (1..8) [floating-point values are MSB-first]\
        10 string [Enumerable] / blob [Not Enumerable]\
                bit2=0 string\
                bit2=1 blob\
                bit3=0 short length\
                      bit4..7 (0..15) not NULL-terminated\
                bit3=1 long length in next byte(s)\
                      bit4 Reserved (set to zero)\
                      bit5..7 number of bytes for length-1 (1..8)\
        11 other\
                bit2..3\
                       00 boolean [Enumerable]\
                             bit4..6 Reserved (set to zero)\
                             bit7=0 False\
                             bit7=1 True\
                       01 start of container (sequence of values) [Not Enumerable]\
                             bit4..5\
                                    00 array\
                                    01 map\
                                    10 set\
                                    11 Reserved\
                             bit6 Reserved (set to zero)\
                             bit7=0 Empty\
                             bit7=1 Number of elements follows, as integer\
                       10 end of container (sequence of values)\
                             bit4..5\
                                    00 array\
                                    01 map\
                                    10 set\
                                    11 Reserved\
                             bit6 Reserved (set to zero)\
                             bit7=0 Empty\
                             bit7=1 Number of elements follows, as integer [must match container start]\
                       11 start/end message\
                             bit4=0 start of message\
                             bit4=1 end of message\
                             bit5=0 Empty\
                             bit5=1 Non-empty\
                             bit6..7 expected first/last value in message if non-empty [top two bits of value type]\
\
note that there is no explicit restriction on the elements; for a map, the elements are expected to be a key / value pair, with the key being an Enumerable, but the format does not add this as a constraint\
the start / end of container entries are used for validation\
\
Examples - [octal]\
SME is 11110xyy [036z] (x=0 for empty message, x=1 for non-empty message, yy=value type of first part of message)\
EME is 11111xyy [037z]\
SAR is 1101000x [032z] (x=0 for empty array, x=1 for non-empty array, element count follows) \
EAR is 1110000x [034z]\
SMA is 1101010x [032z] (x=0 for empty map, x=1 for non-empty map, element count follows)\
EMA is 1110010x [034z]\
SSE is 1101100x [033z] (x=0 for empty set, x=1 for non-empty set, element count follows)\
ESE is 1110100x [035z]\
False is 11000000 [0300]\
True is 11000001 [0301]\
0 is 00000000 [0000]\
13 is 00001101 [0015]\
-13 is 00010011 [0023]\
144 is 00100001 [0041] 00000000 [0000] 10010000 [0220]\
-144 is 00100001 [0041] 11111111 [0377] 01110000 [0160]\
1.23 2.34 4.56 is 01000010 [0102] fb(1.23) fb(2.34) fb(4.56), if float, where fb(x) is the binary representation of the float value x;\
                            01100010 [0142] fd(1.23) fd(2.34) fd(4.56), if double, where fd(x) is the binary representation of the double value x\
"" is 10000000 [0200]\
"abc" is 1000 0011 b('a') b('b') b('c'), where b(x) is the binary representation of the character x\
"abcde abcde abcde abcde abcde abcde " is 10010000 [0220] 00100100 [0044] b('a') b('b') b('c') b('d') b('e') b(' ') \'85 b('e') b(' ')\
\
\cf2 As a complete example, "13 144 1.23 2.45 abc" is SOL(0xD0)+(0x0D)+(0x00,0x90)+(0x61,b(1.23),b(2.45))+(0x83,'a','b','c')+EOL(0xC4)+EOM(0xC0) => 11 + 3 x sizeof(floating-point) [21 bytes as ASCII, including NULL]; with floats, this would be 23 bytes versus 21 bytes and, with doubles, this would be 35 bytes versus 21 bytes. However, the precision of the values using this format is far greater than the representation as ASCII, and the ASCII representation does not include the number of 'slots' to follow.\
\
This uses one byte for SOM, one byte for EOM, one byte for values in the range -16..15, two bytes for values in the range -128..127, three bytes for values in the range -32,768..32,767, four bytes for values in the range -16,777,216..16,777,215, five bytes for values in the range -4,294,967,296..4,292,967,295, et cetera.\
Double values take (1+8*n) bytes, float values take (1+4*n) bytes, strings under 31 bytes in length take n+1 bytes (lead byte. n bytes), strings over 31 bytes in length but less than 256 bytes take n+2 bytes (lead byte, length byte, n bytes), strings over 255 bytes in length but less than 65536 bytes take n+3 bytes (lead byte, two length bytes, n bytes), et cetera.\
Numeric values are always signed.\
\
A single double is 12.5% longer, two doubles are 6.25% longer, three doubles are 4.2% longer, et cetera; a single float is 25% longer, two floats are 12.5% longer, three floats are 8.3% longer, et cetera.\
4-byte longs use between 1 and 5 bytes, so either 75% reduction, 50% reduction, 25% reduction, no difference or 25% increase in length, short strings are the same length, medium strings are 3% longer, long strings are 0.7% longer, et cetera, assuming that the NULL is considered as part of the string.\
\
Note that there is no explicit restriction on the type of the values in a dictionary or the values in a list, but dictionary keys must be 'enumerable' - that is, reproducibly washable, like integers or strings.\
Singular values may appear as either singular lists or 'bare' but multiple values are bracketed by SOL and EOL.\
All values, whether singular or structures, are followed by EOM.\
Multiple SOMs may be used for framing.\
Dictionary elements are unordered, with the key always preceding the value - there is no need for a tag or marker for which is which, and there must be an even number of values between SOD and EOD.\
}